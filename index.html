<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#121212">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">

    <title>Speed Assistant</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #121212;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            text-align: center;
            user-select: none;
            -webkit-user-select: none; 
            overflow: hidden; 
            transition: background-color 0.3s ease;
        }

        /* --- SPLASH SCREEN --- */
        .splash-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000000;
            z-index: 2000;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            padding: 20px; box-sizing: border-box;
            transition: opacity 0.5s ease;
        }
        .splash-overlay.hidden { opacity: 0; pointer-events: none; }
        
        .ad-container {
            width: 300px; height: 250px;
            background-color: #1a1a1a;
            border: 1px dashed #444;
            display: flex; align-items: center; justify-content: center;
            color: #666; margin-bottom: 30px; border-radius: 8px;
            overflow: hidden;
        }

        .start-btn {
            background-color: #30d158; color: black;
            font-size: 1.2rem; font-weight: bold;
            padding: 15px 40px; border: none; border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 20px rgba(48, 209, 88, 0.4);
            text-transform: uppercase;
        }

        /* --- PROGRESS BAR --- */
        .progress-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 30px; 
            background-color: #3a3a3a; border-bottom: 1px solid #555; z-index: 100;
        }
        .progress-fill {
            height: 100%; width: 0%; background-color: #30d158; 
            transition: width 0.1s linear, background-color 0.3s ease; 
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        /* --- UI ELEMENTS --- */
        body.overspeed { background-color: #b71c1c !important; }

        .limit-container {
            border: 10px solid #ff3b30; border-radius: 50%;
            width: 220px; height: 220px;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: white; color: black;
            box-shadow: 0 0 40px rgba(255, 59, 48, 0.2);
            margin-bottom: 40px; margin-top: 30px;
            position: relative; cursor: pointer;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        body.overspeed .limit-container { border-color: white; box-shadow: 0 0 50px rgba(255, 255, 255, 0.4); }

        .limit-label { font-size: 1rem; font-weight: 700; color: #555; margin-bottom: -5px; text-transform: uppercase; }
        .limit-value { font-size: 7rem; font-weight: 900; line-height: 1; letter-spacing: -2px; }

        .current-speed-container { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
        .current-label { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 2px; color: #888; margin-bottom: 5px; transition: color 0.3s; }
        body.overspeed .current-label { color: rgba(255,255,255, 0.8); }
        .current-value { font-size: 5rem; font-weight: 800; font-variant-numeric: tabular-nums; line-height: 1; color: white; }
        .current-unit { font-size: 1.2rem; color: #888; font-weight: 600; transition: color 0.3s; }
        body.overspeed .current-unit { color: rgba(255,255,255, 0.8); }

        /* --- FOOTER --- */
        .footer {
            position: absolute; bottom: 20px;
            display: flex; flex-direction: column; align-items: center; gap: 5px;
        }
        .status { font-size: 0.8rem; color: #666; transition: color 0.3s; }
        .debug-row { display: flex; align-items: center; gap: 10px; }
        .debug-stats { font-size: 0.75rem; font-family: monospace; color: #888; }
        .reset-btn { font-size: 0.65rem; background: #333; color: #ccc; border: 1px solid #555; border-radius: 4px; padding: 2px 5px; cursor: pointer; }
        body.overspeed .status, body.overspeed .debug-stats { color: rgba(255,255,255, 0.6); }
        .wake-status { font-size: 0.7rem; color: #30d158; opacity: 0; transition: opacity 0.5s; }
        .wake-status.active { opacity: 1; }
        body.overspeed .wake-status { color: #66ff85; }

    </style>
</head>
<body>

    <div class="splash-overlay" id="splashScreen">
        <div class="ad-container">
            <div style="text-align:center; padding: 20px;">
                Support this App<br><br><small>(Ad Space)</small>
            </div>
        </div>
        <button class="start-btn" onclick="startApp()">Start Assistant</button>
    </div>

    <div class="progress-container"><div class="progress-fill" id="progressFill"></div></div>

    <div class="limit-container" onclick="requestWakeLock()">
        <div class="limit-label">LIMIT</div>
        <div class="limit-value" id="limitDisplay">--</div>
    </div>

    <div class="current-speed-container" ondblclick="runDemoMode()">
        <div class="current-label">Your Speed (Double Tap to Test)</div>
        <div class="current-value" id="currentSpeedDisplay">0</div>
        <div class="current-unit">MPH</div>
    </div>

    <div class="footer">
        <div class="status" id="statusMsg">Waiting for GPS...</div>
        <div class="debug-row">
            <div class="debug-stats" id="debugStats">OSM: 0 | HERE: 0 | DB: 0</div>
            <button class="reset-btn" onclick="resetStats()">Reset</button>
        </div>
        <div class="wake-status" id="wakeMsg">âš¡ Screen Awake Active</div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const HERE_API_KEY = "6gHvApqVJFF0SKgYUL-DK1pIuSlpm8EjDRMMVrkaH-E"; 
        const FETCH_DISTANCE_THRESHOLD = 50; 
        const MIN_FETCH_INTERVAL = 5000; 

        // --- GLOBAL ELEMENTS ---
        const limitDisplay = document.getElementById('limitDisplay');
        const currentSpeedDisplay = document.getElementById('currentSpeedDisplay');
        const statusMsg = document.getElementById('statusMsg');
        const debugStats = document.getElementById('debugStats');
        const wakeMsg = document.getElementById('wakeMsg');
        const progressFill = document.getElementById('progressFill');
        const splashScreen = document.getElementById('splashScreen');

        // --- STATE VARIABLES ---
        let currentLimit = null; 
        let lastFetchCoords = { lat: 0, lon: 0 };
        let lastFetchTime = 0;
        let firstRun = true;
        let demoLimit = 60; 
        let lastWarningTime = 0; // For Audio throttling

        // Counters
        let osmTotalCalls = parseInt(localStorage.getItem('osmTotalCalls')) || 0;
        let hereTotalCalls = parseInt(localStorage.getItem('hereTotalCalls')) || 0;
        let cachedLookups = 0; 

        // --- AUDIO CONTEXT ---
        let audioCtx = null;

        const highwayDefaults = {
            "motorway": 70, "motorway_link": 70, "trunk": 60, "primary": 60, "secondary": 60,
            "tertiary": 30, "unclassified": 60, "residential": 30, "living_street": 20, "service": 10
        };

        const CacheManager = {
            PRECISION: 4, PREFIX: "sl_",
            getKey: function(lat, lon) { return this.PREFIX + lat.toFixed(this.PRECISION) + "_" + lon.toFixed(this.PRECISION); },
            get: function(lat, lon) {
                try { return JSON.parse(localStorage.getItem(this.getKey(lat, lon))); } catch(e) { return null; }
            },
            save: function(lat, lon, limit) {
                const key = this.getKey(lat, lon);
                const record = { l: limit, t: Date.now() };
                try { localStorage.setItem(key, JSON.stringify(record)); } catch (e) {
                    if (e.name === 'QuotaExceededError') { this.prune(); try { localStorage.setItem(key, JSON.stringify(record)); } catch(e2){} }
                }
            },
            prune: function() {
                let items = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(this.PREFIX)) {
                        try { items.push({ key: key, t: JSON.parse(localStorage.getItem(key)).t }); } catch(e){}
                    }
                }
                items.sort((a, b) => a.t - b.t);
                const deleteCount = Math.max(1, Math.floor(items.length * 0.2));
                for (let i = 0; i < deleteCount; i++) { localStorage.removeItem(items[i].key); }
            },
            count: function() {
                let c = 0;
                for(let i=0; i<localStorage.length; i++) if(localStorage.key(i).startsWith(this.PREFIX)) c++;
                return c;
            }
        };

        // --- SPLASH & AUDIO STARTUP ---
        function startApp() {
            splashScreen.classList.add('hidden');
            requestWakeLock();
            
            // Initialize AudioContext on user interaction (required by browsers)
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            }
            // Resume if suspended
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // --- WARNING SOUND LOGIC ---
        function playWarningSound() {
            if (!audioCtx) return;

            // Simple Beep (Sine Wave)
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5 note (Standard dashboard beep)
            
            // Volume Envelope (Attack/Decay to avoid clicking)
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.5);
        }

        // --- DISTANCE LOGIC ---
        function getDistanceFromLatLonInMeters(lat1, lon1, lat2, lon2) {
            const R = 6371e3; 
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
            return R * c; 
        }
        function deg2rad(deg) { return deg * (Math.PI/180); }

        function updateDebug() {
            debugStats.textContent = `OSM:${osmTotalCalls} | HERE:${hereTotalCalls} | DB:${CacheManager.count()}`;
            localStorage.setItem('osmTotalCalls', osmTotalCalls);
            localStorage.setItem('hereTotalCalls', hereTotalCalls);
        }

        function resetStats() {
            if(confirm("Reset counters and clear database?")) {
                osmTotalCalls = 0; hereTotalCalls = 0;
                const keysToRemove = [];
                for(let i=0; i<localStorage.length; i++) {
                    if(localStorage.key(i).startsWith(CacheManager.PREFIX)) keysToRemove.push(localStorage.key(i));
                }
                keysToRemove.forEach(k => localStorage.removeItem(k));
                updateDebug();
            }
        }

        // --- CORE UPDATE LOGIC ---
        function updateSpeedLimit(lat, lon, heading) {
            lastFetchCoords = { lat: lat, lon: lon };

            const cached = CacheManager.get(lat, lon);
            if (cached) {
                setLimitDisplay(cached.l);
                statusMsg.textContent = "Source: Local DB";
                cachedLookups++;
                updateDebug(); 
                return; 
            }

            statusMsg.textContent = "Checking OSM...";
            osmTotalCalls++;
            updateDebug();
            
            const query = `[out:json];way(around:20,${lat},${lon})["highway"];out tags;`;
            const url = "https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(query);

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    let foundLimit = null;
                    let source = "";

                    if (data.elements && data.elements.length > 0) {
                        let road = data.elements.find(e => e.tags.maxspeed) || data.elements[0];
                        if (road.tags.maxspeed) {
                            foundLimit = parseMaxSpeed(road.tags.maxspeed);
                            source = "OSM Signage";
                        } else if (road.tags.highway && highwayDefaults[road.tags.highway]) {
                            foundLimit = highwayDefaults[road.tags.highway];
                            source = `OSM Default (${road.tags.highway})`;
                        }
                    }

                    if (foundLimit) {
                        setLimitDisplay(foundLimit);
                        statusMsg.textContent = source;
                        CacheManager.save(lat, lon, foundLimit);
                        updateDebug();
                    } else {
                        if (HERE_API_KEY) {
                            fetchHereSpeedLimit(lat, lon, heading);
                        } else {
                            setLimitDisplay("?");
                            statusMsg.textContent = "No Data (OSM)";
                        }
                    }
                })
                .catch(err => {
                    console.error("OSM Error:", err);
                    if (HERE_API_KEY) fetchHereSpeedLimit(lat, lon, heading);
                });
        }

        function fetchHereSpeedLimit(lat, lon, heading) {
            statusMsg.textContent = "Checking HERE Maps...";
            hereTotalCalls++;
            updateDebug();
            
            const offset = 0.0001; 
            const baseUrl = "https://routematching.hereapi.com/v8/match/routelinks";
            const params = `apikey=${HERE_API_KEY}&waypoint0=${lat},${lon}&waypoint1=${lat+offset},${lon+offset}&mode=fastest;car&attributes=SPEED_LIMITS_FCn(*)`;

            fetch(`${baseUrl}?${params}`)
                .then(res => res.json())
                .then(data => {
                    try {
                        const link = data.response.route[0].leg[0].link[0];
                        const attributes = link.attributes;
                        let speedKmh = 0;
                        const keys = Object.keys(attributes);
                        for (const key of keys) {
                            if (key.startsWith("SPEED_LIMITS_FC") && attributes[key].length > 0) {
                                const val = attributes[key][0];
                                const v1 = parseInt(val.FROM_REF_SPEED_LIMIT) || 0;
                                const v2 = parseInt(val.TO_REF_SPEED_LIMIT) || 0;
                                speedKmh = Math.max(v1, v2);
                                break; 
                            }
                        }

                        if (speedKmh > 0) {
                            const mph = Math.round(speedKmh * 0.621371);
                            setLimitDisplay(mph);
                            statusMsg.textContent = "Source: HERE Maps";
                            CacheManager.save(lat, lon, mph);
                            updateDebug();
                        } else { throw new Error("No limit"); }
                    } catch (e) {
                        setLimitDisplay("?");
                        statusMsg.textContent = "No Data";
                    }
                })
                .catch(err => {
                    setLimitDisplay("?");
                    statusMsg.textContent = "Data Unavailable";
                });
        }

        function parseMaxSpeed(speedStr) {
            return parseInt(speedStr.toLowerCase().replace("mph", "").trim());
        }

        function setLimitDisplay(val) {
            limitDisplay.textContent = val;
            currentLimit = (typeof val === 'number') ? val : null;
            if(currentLimit) demoLimit = currentLimit; 
            checkOverspeed();
        }

        function updateCurrentSpeed(speedMs) {
            const mph = speedMs ? Math.round(speedMs * 2.23694) : 0;
            currentSpeedDisplay.textContent = mph;
            checkOverspeed(mph);
        }

        function checkOverspeed(currentMph) {
            if (currentMph === undefined) currentMph = parseInt(currentSpeedDisplay.textContent);
            let limitToUse = currentLimit || 100; 
            let percentage = (currentMph / limitToUse) * 100;
            if(percentage > 100) percentage = 100;

            let barColor = "#30d158"; // Green
            if (currentMph >= limitToUse) { barColor = "#ff3b30"; } 
            else if (percentage >= 90) { barColor = "#ffcc00"; }

            progressFill.style.width = percentage + "%";
            progressFill.style.backgroundColor = barColor;

            if (currentLimit !== null && currentMph > currentLimit) { 
                document.body.classList.add('overspeed'); 
                
                // CHECK AUDIO WARNING
                const now = Date.now();
                if (now - lastWarningTime > 10000) { // 10 seconds (10000 ms)
                    playWarningSound();
                    lastWarningTime = now;
                }

            } else { 
                document.body.classList.remove('overspeed'); 
            }
        }

        // --- DEMO MODE ---
        let demoInterval = null;
        function runDemoMode() {
            if(demoInterval) return; 
            if(!currentLimit) { setLimitDisplay(60); statusMsg.textContent = "Demo Mode (60mph limit)"; }
            let fakeSpeed = 0; let goingUp = true;
            demoInterval = setInterval(() => {
                if(goingUp) { fakeSpeed += 2; if(fakeSpeed >= demoLimit + 10) goingUp = false; } 
                else { fakeSpeed -= 2; if(fakeSpeed <= 0) { fakeSpeed = 0; clearInterval(demoInterval); demoInterval = null; statusMsg.textContent = "Demo Ended"; } }
                currentSpeedDisplay.textContent = fakeSpeed; checkOverspeed(fakeSpeed);
            }, 50); 
        }

        if ("geolocation" in navigator) {
            navigator.geolocation.watchPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    const acc = position.coords.accuracy;
                    const speed = position.coords.speed;
                    const heading = position.coords.heading;
                    const now = Date.now();

                    if(speed > 1 && demoInterval) { clearInterval(demoInterval); demoInterval = null; }
                    updateCurrentSpeed(speed);

                    const dist = getDistanceFromLatLonInMeters(lat, lon, lastFetchCoords.lat, lastFetchCoords.lon);
                    const timeElapsed = now - lastFetchTime;

                    if (acc < 50) {
                        if (firstRun || (dist > FETCH_DISTANCE_THRESHOLD && timeElapsed > MIN_FETCH_INTERVAL)) {
                            firstRun = false;
                            lastFetchTime = now;
                            updateSpeedLimit(lat, lon, heading);
                        }
                    }
                },
                (error) => { statusMsg.textContent = "GPS Access Denied"; },
                { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
            );
        } else { statusMsg.textContent = "Geolocation not supported."; }

        let wakeLock = null;
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeMsg.classList.add('active');
                    wakeLock.addEventListener('release', () => { wakeMsg.classList.remove('active'); });
                } catch (err) { console.log(err); }
            }
        }
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') { await requestWakeLock(); }
        });

    </script>
</body>
</html>
